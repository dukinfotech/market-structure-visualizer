// @version=5
indicator("MACD-based Market Structure Visualizer", overlay=true, max_bars_back = 500) // Tăng max_bars_back

// --- INPUTS ---




// Getting inputs
histogramMinLen = input.int(title = "Histogram Min Length", minval=1, defval=2)
fastLen = input(title = "Fast Length", defval = 12)
slowLen = input(title = "Slow Length", defval = 26)
src = input(title = "Source", defval = close, display = display.data_window)
signalLen = input.int(title = "Signal Smoothing",  minval = 1, maxval = 50, defval = 9)
sma_source = input.string(title = "Oscillator MA Type",  defval = "EMA", options = ["SMA", "EMA"], display = display.data_window)
sma_signal = input.string(title = "Signal Line MA Type", defval = "EMA", options = ["SMA", "EMA"], display = display.data_window)

// Calculating
fastMA = sma_source == "SMA" ? ta.sma(src, fastLen) : ta.ema(src, fastLen)
slowMA = sma_source == "SMA" ? ta.sma(src, slowLen) : ta.ema(src, slowLen)
macd = fastMA - slowMA
signal = sma_signal == "SMA" ? ta.sma(macd, signalLen) : ta.ema(macd, signalLen)
histogram = macd - signal


// --- SWING/CROSS POINT LOGIC ---
// Lưu trữ chỉ mục các nến xảy ra cắt nhau
var int[] crossBarIndexs = array.new_int()
var line lastLine = na // Biến để lưu trữ đối tượng đường kẻ cuối cùng


// --- KIỂM TRA TÍN HIỆU CẮT NHAU ---
// Phát hiện tại histogram trước đã đảo chiều (có xác nhận bởi nến đóng cửa), cây nến hiện tại là cấy nến của histogram thứ 2
bool isCross = histogram * histogram[1] > 0 and barstate.isconfirmed

// Kiểm tra các thanh histogram trung gian có đổi chiều không
for i = 1 to histogramMinLen - 1
    isCross := isCross and histogram[i] * histogram[i + 1] < 0

// Kiểm tra thanh histogram cuối cùng có cùng chiều với thanh hiện tại không
isCross := isCross and histogram[histogramMinLen] * histogram[histogramMinLen + 1] > 0


// --- XỬ LÝ KHI CÓ TÍN HIỆU CẮT NHAU ---
if isCross
    int crossBarIndex = bar_index - 1 // Chỉ mục thanh trước (thanh xảy ra tín hiệu cắt)
    
    // 1. Lưu chỉ mục của cây nến hiện tại khi có tín hiệu cắt
    array.push(crossBarIndexs, crossBarIndex)
    
    crossBarSize = array.size(crossBarIndexs)

    // 2. Chỉ tính toán và vẽ khi có ít nhất 2 điểm cắt (cần 2 chỉ mục: current, last)
    if crossBarSize >= 2
        // Lấy 2 chỉ mục của 2 cây nến xảy ra tín hiệu cắt gần nhất:
        int currentCrossIndex = array.get(crossBarIndexs, crossBarSize - 1)
        int lastCrossIndex    = array.get(crossBarIndexs, crossBarSize - 2)

        // --- TÌM ĐIỂM CỰC TRỊ TRONG SWING TRƯỚC ---
        // Tìm giá cực trị giữa lastCrossIndex và currentCrossIndex.
        
        // Khởi tạo giá trị cao nhất
        float extremePrice = -1000000.0
        int extremeBarIndex = 0
        
        // Vòng lặp để tìm giá cao nhất/thấp nhất TỪ lastCrossIndex ĐẾN currentCrossIndex
        // Index trong Pine Script được tham chiếu bằng [offset]
        // Offset cho lastCrossIndex là bar_index - lastCrossIndex
        // Offset cho currentCrossIndex là bar_index - currentCrossIndex

        int offsetStart = crossBarIndex - currentCrossIndex // Bắt đầu từ nến gần nhất của swing
        int offsetEnd = crossBarIndex - lastCrossIndex // Kết thúc ở nến xa nhất của swing

        bool isBearSwing = histogram[offsetEnd] < 0
        
        extremePrice := isBearSwing ? 1e10 : -1e10

        // Duyệt các offset từ gần tới xa (offEnd -> offStart)
        for i = offsetEnd to offsetStart
            if isBearSwing
                // swing down -> tìm giá thấp nhất
                if low[i] < extremePrice
                    extremePrice := low[i]  
                    extremeBarIndex := bar_index - i
            else
                // swing up -> tìm giá cao nhất
                if high[i] > extremePrice
                    extremePrice := high[i]
                    extremeBarIndex := bar_index - i

        float extremeBarYloc = isBearSwing ? low[bar_index - extremeBarIndex] - 5 : high[bar_index - extremeBarIndex] + 5
        color extremeBarColor = isBearSwing ? color.red : color.green
        string extremeBarStyle = isBearSwing ? label.style_label_up : label.style_label_down
        label.new(extremeBarIndex, extremeBarYloc, text=str.tostring(extremePrice), color=extremeBarColor, style=extremeBarStyle, textcolor=color.black, size=size.small)
       
        // Lưu trữ điểm Peak A (điểm High/Low mới tìm được)
        float peak_A_price = extremePrice

        // Lấy chỉ mục nến của Peak A
        int peak_A_index = extremeBarIndex
        
        // --- VẼ ĐƯỜNG NỐI TỪ ĐIỂM CŨ ĐẾN ĐIỂM MỚI ---
        if not na(lastLine)
            // Lấy tọa độ cuối cùng của đường cũ (Peak B)
            int peak_B_index = line.get_x2(lastLine)
            float peak_B_price = line.get_y2(lastLine)
            
            // Vẽ đường mới nối Peak B (điểm cuối của đường cũ) với Peak A (điểm High mới tìm được)
            line.new(peak_B_index, peak_B_price, peak_A_index, peak_A_price, 
                 xloc=xloc.bar_index, style=line.style_solid, width=3, color=color.new(color.blue, 0))
            
            // Cần cập nhật line.new() cuối cùng để lần sau lấy điểm cuối
            line.set_xy2(lastLine, peak_A_index, peak_A_price) 
        else
            // Lần chạy đầu tiên, chỉ lưu Peak A để lần sau dùng làm Peak B
            lastLine := line.new(peak_A_index, peak_A_price, peak_A_index, peak_A_price, 
                 xloc=xloc.bar_index, style=line.style_solid, width=1, color=color.new(color.gray, 100)) // Đường ẩn